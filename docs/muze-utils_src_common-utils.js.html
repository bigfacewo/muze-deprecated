<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: muze-utils/src/common-utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: muze-utils/src/common-utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* global window, requestAnimationFrame, cancelAnimationFrame */
import { FieldType, DimensionSubtype } from 'datamodel';
import {
    axisLeft,
    axisRight,
    axisTop,
    axisBottom
} from 'd3-axis';
import {
    symbolCircle,
    symbolCross,
    symbolDiamond,
    symbolSquare,
    symbolStar,
    symbolWye,
    symbolTriangle,
    symbol,
    stack as d3Stack,
    stackOffsetDiverging,
    stackOrderNone,
    stackOrderAscending,
    stackOrderDescending,
    stackOffsetNone,
    stackOffsetExpand,
    stackOffsetWiggle,
    pie,
    arc,
    line,
    curveLinear,
    curveStepAfter,
    curveStepBefore,
    curveStep,
    curveCatmullRom,
    area
} from 'd3-shape';
import { scaleBand } from 'd3-scale';
import { nest } from 'd3-collection';
import {
    interpolate,
    interpolateRgb,
    piecewise,
    interpolateNumber,
    interpolateHslLong
} from 'd3-interpolate';
import {
    easeCubic,
    easeBounce,
    easePoly,
    easeBack,
    easeCircle,
    easeLinear,
    easeElastic
} from 'd3-ease';
import {
   color,
   rgb,
   hsl
} from 'd3-color';
import { voronoi } from 'd3-voronoi';
import Model from 'hyperdis';
import * as STACK_CONFIG from './enums/stack-config';

const HTMLElement = window.HTMLElement;

const isSimpleObject = (obj) => {
    let token;
    if (typeof obj === 'object') {
        if (obj === null) { return false; }
        token = Object.prototype.toString.call(obj);
        if (token === '[object Object]') {
            return (obj.constructor.toString().match(/^function (.*)\(\)/m) || [])[1] === 'Object';
        }
    }
    return false;
};

/**
 * Returns unique id
 * @return {string} Unique id string
 */
const
    getUniqueId = () => `id-${new Date().getTime()}${Math.round(Math.random() * 10000)}`;

/**
 * Deep copies an object and returns a new object.
 * @param {Object} o Object to clone
 * @return {Object} New Object.
 */
const clone = (o) => {
    const output = {};
    let v;
    for (const key in o) {
        if ({}.hasOwnProperty.call(o, key)) {
            v = o[key];
            output[key] = isSimpleObject(v) ? clone(v) : v;
        }
    }
    return output;
};

/**
* Checks the existence of keys in an object
* @param {Array} keys Set of keys which are to be checked
* @param {Object} obj whose keys are checked from the set of keys provided
* @return {Object} Error if the keys are absent, or the object itself
*/
const checkExistence = (keys, obj) => {
    const nonExistentKeys = [];
    keys.forEach((key) => {
        if (key in obj) {
            return;
        }
        nonExistentKeys.push(key);
    });
    return nonExistentKeys;
};

const sanitizeIP = {
    typeObj: (keys, obj) => {
        if (typeof obj !== 'object') {
            return Error('Argument type object expected');
        }

        const nonExistentKeys = checkExistence(keys, obj);
        if (nonExistentKeys.length) {
            return Error(`Missing keys from parameter ${nonExistentKeys.join(', ')}`);
        }
        return obj;
    },

    /* istanbul ignore next */ htmlElem: (elem) => {
        if (!(elem instanceof HTMLElement)) {
            return Error('HTMLElement required');
        }
        return elem;
    }
};

/**
 * Gets the maximum value from an array of objects for a given property name
 * @param  {Array.&lt;Object>} data   Array of objects
 * @param  {string} field Field name
 * @return {number} Maximum value
 */
const getMax = (data, field) => Math.max(...data.filter(d => !isNaN(d[field])).map(d => d[field]));

/**
 * Gets the minimum value from an array of objects for a given property name
 * @param  {Array.&lt;Object>} data   Array of objects
 * @param  {string} field Field name
 * @return {number} Minimum value
 */
const getMin = (data, field) => Math.min(...data.filter(d => !isNaN(d[field])).map(d => d[field]));

/**
 * Gets the domain from the data based on the field name and type of field
 * @param  {Array.&lt;Object> | Array.&lt;Array>} data       Data Array
 * @param  {Array.&lt;string>} fields    Array of fields from where the domain will be calculated
 * @param {string} fieldType Type of field - nominal, quantitiative, temporal.
 * @return {Array} Usually contains a min and max value if field is quantitative or
 * an array of values if field type is nominal or ordinal
 */
const getDomainFromData = (data, fields, fieldType) => {
    let domain;
    let domArr;
    data = data[0] instanceof Array ? data : [data];
    switch (fieldType) {
    case DimensionSubtype.CATEGORICAL:
        domain = [].concat(...data.map(arr => arr.map(d => d[fields[0]]).filter(d => d !== undefined)));
        break;
    default:
        domArr = data.map((arr) => {
            const firstMin = getMin(arr, fields[0]);
            const secondMin = getMin(arr, fields[1]);
            const firstMax = getMax(arr, fields[0]);
            const secondMax = getMax(arr, fields[1]);
            return [Math.min(firstMin, secondMin), Math.max(firstMax, secondMax)];
        });
        domain = [Math.min(...domArr.map(d => d[0])), Math.max(...domArr.map(d => d[1]))];
        break;
    }
    return domain;
};

/**
 * Union Domain values
 * @param {Array.&lt;Array>} domains Array of domain values
 * @param {string} fieldType type of field - dimension,measure or datetime.
 * @return {Array} Unioned domain of all domain values.
 */
const unionDomain = (domains, fieldType) => {
    let domain;
    domains = domains.filter(dom => dom.length);
    if (fieldType === DimensionSubtype.CATEGORICAL) {
        domain = domain = [].concat(...domains);
    } else {
        domain = [Math.min(...domains.map(d => d[0])), Math.max(...domains.map(d => d[1]))];
    }

    return domain;
};

const symbolFns = {
    circle: symbolCircle,
    cross: symbolCross,
    diamond: symbolDiamond,
    square: symbolSquare,
    star: symbolStar,
    wye: symbolWye,
    triangle: symbolTriangle
};

const easeFns = {
    cubic: easeCubic,
    bounce: easeBounce,
    linear: easeLinear,
    elastic: easeElastic,
    back: easeBack,
    poly: easePoly,
    circle: easeCircle
};

/**
 * Returns the maximum or minimum points of a compare value from an array of objects.
 * @param {Array} points Array of objects
 * @param {string} compareValue Key in the object on which the comparing will be done.
 * @param {string} minOrMax minimum or maximum.
 * @return {Object} Minimum or maximum point.
 */
const getExtremePoint = (points, compareValue, minOrMax) => {
    let extremePoint;
    let point;
    const len = points.length;
    let minOrMaxVal = minOrMax === 'max' ? -Infinity : Infinity;
    let val;

    for (let i = 0; i &lt; len; i++) {
        point = points[i];
        val = point[compareValue];
        if (minOrMax === 'min' ? val &lt; minOrMaxVal : val > minOrMaxVal) {
            minOrMaxVal = val;
            extremePoint = point;
        }
    }

    return extremePoint;
};

/**
 * Returns the minimum point of a compare value from an array of objects.
 * @param {Array} points Array of objects
 * @param {string} compareValue Key in the object on which the comparing will be done.
 * @return {Object} Minimum point.
 */
const getMinPoint = (points, compareValue) => getExtremePoint(points, compareValue, 'min');

/**
 * Returns the maximum point of a compare value from an array of objects.
 * @param {Array} points Array of objects
 * @param {string} compareValue Key in the object on which the comparing will be done.
 * @return {Object} Maximum point.
 */
const getMaxPoint = (points, compareValue) => getExtremePoint(points, compareValue, 'max');

/**
 * Gets the index of the closest value of the given value from the array.
 * @param {Array} arr Array of values
 * @param {number} value Value from which the nearest value will be calculated.
 * @param {string} side side property.
 * @return {number} index of the closest value
 */
/* istanbul ignore next */const getClosestIndexOf = (arr, value, side) => {
    let low = 0;
    const arrLen = arr.length;
    let high = arrLen - 1;

    let mid;
    let d1;
    let d2;

    while (low &lt; high) {
        mid = Math.floor((low + high) / 2);
        d1 = Math.abs(arr[mid] - value);
        d2 = Math.abs(arr[mid + 1] - value);

        if (d2 &lt;= d1) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }

    if (!side) {
        return high;
    }

    const highVal = arr[high];
    if (highVal === value) {
        return high;
    } else if (highVal > value) {
        if (high === 0) { return high; }
        return side === 'left' ? high - 1 : high;
    }
    if (high === arr.length - 1) { return high; }
    return side === 'left' ? high : high + 1;
};

/**
 * Returns the browser window object
 * @return {Window} Window object
*/
const getWindow = () => window;

/**
 * Returns the browser window object
 * @return {Window} Window object
*/
const reqAnimFrame = (() => requestAnimationFrame)();

const cancelAnimFrame = (() => cancelAnimationFrame)();

/**
 * Capitalizes the first letter of the word
 * @param {string} text word
 * @return {string} Capitalized word
 */
const capitalizeFirst = (text) => {
    text = text.toLowerCase();

    return text.replace(/\w\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1));
};

/**
 *
 *
 * @param {*} arr
 */
const unique = arr => ([...new Set(arr)]);

/**
 * Gets the minimum difference between two consecutive numbers  in an array.
 * @param {Array} arr Array of numbers
 * @param {number} index index of the value
 * @return {number} minimum difference between values
 */
/* istanbul ignore next */ const getMinDiff = (arr, index) => {
    let diff;
    let uniqueVals;
    if (index !== undefined) {
        uniqueVals = unique(arr.map(d => d[index]));
    } else {
        uniqueVals = unique(arr);
    }
    if (uniqueVals.length > 1) {
        diff = Math.abs(uniqueVals[1] - uniqueVals[0]);
        for (let i = 2, len = uniqueVals.length; i &lt; len; i++) {
            diff = Math.min(diff, Math.abs(uniqueVals[i] - uniqueVals[i - 1]));
        }
    } else {
        diff = uniqueVals[0];
    }

    return diff;
};

/**
 * Returns the class name appended with a given id.
 * @param {string} cls class name
 * @param {string} id unique identifier
 * @param {string} prefix string needed to add before the classname
 * @return {string} qualified class name
 */
/* istanbul ignore next */const getQualifiedClassName = (cls, id, prefix) => {
    cls = cls.replace(/^\.*/, '');
    return [`${prefix}-${cls}`, `${prefix}-${cls}-${id}`];
};

/**
 * This method is used to set the default value for variables
 * without sullying the code with conditional statements.
 *
 * @export
 * @param {any} param The parameter to test.
 * @param {any} value The default value to assign.
 * @return {any} The value.
 */
/* istanbul ignore next */ const defaultValue = (param, value) => {
    if (typeof param === 'undefined' || (typeof param === 'object' &amp;&amp; !param)) {
        return value;
    }
    return param;
};

/**
 * DESCRIPTION TODO
 *
 * @export
 * @param {Object} graph graph whose dependency order has to be generated
 * @return {Object}
 */
const getDependencyOrder = (graph) => {
    const dependencyOrder = [];
    const visited = {};
    const keys = Object.keys(graph);
    /**
     * DESCRIPTION TODO
     *
     * @export
     * @param {Object} name
     * @return {Object}
     */
    const visit = (name) => {
        if (dependencyOrder.length === keys.length) {
            return true;
        }
        visited[name] = true;
        const edges = graph[name];
        for (let e = 0; e &lt; edges.length; e++) {
            const dep = edges[e];
            if (!visited[dep]) {
                visit(dep);
            }
        }

        dependencyOrder.push(name);
        return false;
    };

    for (let i = 0; i &lt; keys.length; i++) {
        if (visit(keys[i], i)) break;
    }

    return dependencyOrder;
};

/**
 * Iterates over the properties of an object and applies the function
 *
 * @param {any} obj object to be iterated upon
 * @param {any} fn  function to be applied on it
 */
const objectIterator = (obj, fn) => {
    for (const key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) {
            fn(key, obj);
        }
    }
};

/**
 * This class creates a d3 voronoi for retrieving the nearest neighbour of any point from a set of two
 * dimensional points
 * @class Voronoi
 */
/* istanbul ignore next */ class Voronoi {
    /**
     * Initialize the voronoi with the data given.
     * @param {Array.&lt;Object>} data Array of points.
     */
    constructor (data) {
        this._voronoi = voronoi().x(d => d.x).y(d => d.y);
        this.data(data);
    }

    /**
     * Sets the data to voronoi
     * @param {Array.&lt;Object>} data Array of objects.
     * @return {Voronoi} Instance of voronoi.
     */
    data (data) {
        if (data) {
            this._voronoiFn = this._voronoi(data);
        }
        return this;
    }

    /**
     * Finds the closest point to the x and y position given.
     * @param {number} x x value
     * @param {number} y y value
     * @param {number} radius search radius.
     * @return {Object} Details of the nearest point.
     */
    find (x, y, radius) {
        return this._voronoiFn.find(x, y, radius);
    }
}

/**
 * Methods to handle changes to table configuration and reactivity are handled by this
 * class.
 */
/**
 *  Common store class
 *
 * @class Store
 */
class Store {
    /**
     * Creates an instance of Store.
     * @param {Object} config The object to create the state store with.
     * @memberof Store
     */
    constructor (config) {
        // create reactive model
        this.model = Model.create(config);
        this._listeners = [];
    }

    /**
     * This method returns a plain JSON object
     * with all the fields in the state store.
     *
     * @return {Object} Serialized representation of state store.
     * @memberof Store
     */
    serialize () {
        return this.model.serialize();
    }

    /**
     * This method is used to update the value of a property in the state store.
     *
     * @param {string} propName The name of the property.
     * @param {number} value The new value of the property.
     * @memberof Store
     */
    commit (propName, value) {
        // check if appropriate enum has been used
        this.model.prop(propName, value);
    }

    /**
     * This method is used to register a callbacl that will execute
     * when one or more properties change.
     *
     * @param {string | Array} propNames name of property or array of props.
     * @param {Function} callBack The callback to execute.
     * @memberof Store
     */
    /* istanbul ignore next */registerChangeListener (propNames, callBack, instantCall) {
        let props = propNames;
        if (!Array.isArray(propNames)) {
            props = [propNames];
        }
        const fn = this.model.next(props, callBack, instantCall);
        this._listeners.push(fn);
        return this;
    }
    /**
     * This method is used to register a callbacl that will execute
     * when one or more properties change.
     *
     * @param {string | Array} propNames name of property or array of props.
     * @param {Function} callBack The callback to execute.
     * @memberof Store
     */
    /* istanbul ignore next */ registerImmediateListener (propNames, callBack, instantCall) {
        let props = propNames;
        if (!Array.isArray(propNames)) {
            props = [propNames];
        }
        const fn = this.model.on(props, callBack, instantCall);
        this._listeners.push(fn);
        return this;
    }
    /**
     * This method is used to get the name of the property
     * from the state store.
     *
     * @param {string} propName The name of the field in state store.
     * @return {any} The value of the field.
     * @memberof Store
     */
    get (propName) {
        return this.model.prop(propName);
    }

    /**
     * This method is used to register a computed property that is computed every time
     * the store value changes.
     *
     * @param {string} propName The name of the property to create.
     * @param {Function} callBack The function to execute when depemdent props change.
     * @memberof Store
     */
    computed (propName, callBack) {
        return this.model.calculatedProp(propName, callBack);
    }

    unsubscribeAll () {
        this._listeners.forEach(fn => fn());
    }
}

/**
 * Sanitize an input number / string mixed number. Currently dot in the no is not supported.
 *
 * @param {number | string} val pure number or string mixed number
 * @return {number | null}  Number if it can be extracted. Otherwise null
 */
const intSanitizer = (val) => {
    const arr = val.toString().match(/(\d+)(px)*/g);
    if (!arr) {
        // If only characters are passed
        return null;
    }

    return parseInt(arr[0], 10);
};

/**
 * Setter getter creator from config
 * Format
 *  PROPERTRY_NAME: {
 *      value: // default value of the property,
 *      meta: {
 *          typeCheck: // The setter value will be checked using this. If the value is function then the setter value
 *                     // is passed as args. (Optional)
 *          typeExpected: // The output of typecheck action will be tested against this. Truthy value will set the
 *                       // value to the setter
 *          sanitizaiton: // Need for sanitization before type is checked
 *      }
 *  }
 *
 * @param {Object} holder an empty object on which the getters and setters will be mounted
 * @param {Object} options options config based on which the getters and setters are determined.
 * @param {Hyperdis} model optional model to attach the property. If not sent new moel is created.
 * @return {Array}
 */
const transactor = (holder, options, model) => {
    let conf;
    const store = model &amp;&amp; model instanceof Model ? model : Model.create({});

    for (const prop in options) {
        if ({}.hasOwnProperty.call(options, prop)) {
            conf = options[prop];
            if (!store.prop(prop)) {
                store.append({ [prop]: conf.value });
            }
            holder[prop] = ((context, key, meta) => (...params) => {
                let val;
                let compareTo;
                const paramsLen = params.length;
                const prevVal = store.prop(prop);
                if (paramsLen) {
                    // If parameters are passed then it's a setter
                    const spreadParams = meta &amp;&amp; meta.spreadParams;
                    val = params;
                    const values = [];
                    if (meta) {
                        for (let i = 0; i &lt; paramsLen; i++) {
                            val = params[i];
                            const sanitization = meta.sanitization &amp;&amp; (spreadParams ? meta.sanitization[i] :
                                meta.sanitization);
                            const typeCheck = meta.typeCheck &amp;&amp; (spreadParams ? meta.typeCheck[i] : meta.typeCheck);
                            if (sanitization &amp;&amp; typeof sanitization === 'function') {
                                // Sanitize if required
                                val = sanitization(val, prevVal, holder);
                            }

                            if (typeCheck) {
                                // Checking if a setter is valid
                                if (typeof typeCheck === 'function') {
                                    let typeExpected = meta.typeExpected;
                                    if (typeExpected &amp;&amp; spreadParams) {
                                        typeExpected = typeExpected[i];
                                    }
                                    if (typeExpected) {
                                        compareTo = typeExpected;
                                    } else {
                                        compareTo = true;
                                    }

                                    if (typeCheck(val) === compareTo) {
                                        values.push(val);
                                    }
                                } else if (typeof typeCheck === 'string') {
                                    if (typeCheck === 'constructor') {
                                        const typeExpected = spreadParams ? meta.typeExpected[i] : meta.typeExpected;
                                        if (val &amp;&amp; (val.constructor.name === typeExpected)) {
                                            values.push(val);
                                        }
                                    }
                                } else {
                                    // context.prop(key, val);
                                    values.push(val);
                                }
                            } else {
                                values.push(val);
                            }
                        }
                        const preset = meta.preset;
                        const oldValues = context.prop(key);
                        preset &amp;&amp; preset(values[0], holder);
                        if (spreadParams) {
                            oldValues.forEach((value, i) => {
                                if (values[i] === undefined) {
                                    values[i] = value;
                                }
                            });
                        }
                        values.length &amp;&amp; context.prop(key, spreadParams ? values : values[0]);
                    } else {
                        context.prop(key, spreadParams ? val : val[0]);
                    }
                    return holder;
                }
            // No parameters are passed hence its a getter
                return context.prop(key);
            })(store, prop, conf.meta);
        }
    }

    return [holder, store];
};

/**
 *
 *
 * @param {*} context
 * @param {*} props
 */
const generateGetterSetters = (context, props) => {
    Object.entries(props).forEach((propInfo) => {
        const prop = propInfo[0];
        const typeChecker = propInfo[1].typeChecker;
        const sanitization = propInfo[1].sanitization;
        const prototype = context.constructor.prototype;
        if (!(Object.hasOwnProperty.call(prototype, prop))) {
            context[prop] = (...params) => {
                if (params.length) {
                    let value = params[0];
                    if (sanitization) {
                        value = sanitization(context, params[0]);
                    }
                    if (typeChecker &amp;&amp; !typeChecker(value)) {
                        return context[`_${prop}`];
                    }
                    context[`_${prop}`] = value;
                    return context;
                } return context[`_${prop}`];
            };
        }
    });
};

/**
 *
 *
 * @param {*} arr
 * @param {*} prop
 */
const getArraySum = (arr, prop) => arr.reduce((total, elem) => {
    total += prop ? elem[prop] : elem;
    return total;
}, 0);

/**
 *
 *
 * @param {*} arr1
 * @param {*} arr2
 *
 */
const arraysEqual = (arr1, arr2) => {
    if (arr1.length !== arr2.length) { return false; }
    for (let i = arr1.length; i >= 0; i--) {
        if (arr1[i] !== arr2[i]) { return false; }
    }

    return true;
};

/* eslint valid-typeof:0 */
/**
 * Returns a validation function which can be used to validate variables against a type and value
 *
 * @param {any} type type of value that the object should have
 * @return {Object} validation function
 */
const isEqual = type => (oldVal, newVal) => {
    if (type === 'Array') {
        if (!oldVal) {
            return false;
        }
        return arraysEqual(oldVal, newVal);
    } else if (type === 'Object') {
        return Object.is(oldVal, newVal);
    } return oldVal === newVal;
};

/**
 * Description @todo
 *
 * @param {any} transactionModel @todo
 * @param {any} transactionEndpoint @todo
 * @param {any} transactionItems @todo
 * @return {any} @todo
 */
const enableChainedTransaction = (transactionModel, transactionEndpoint, transactionItems) =>
    transactionItems.forEach(item => transactionModel.on(item, ([, newVal]) => transactionEndpoint[item](newVal)));

/**
 * Chceks if the element is istanceof HTMLElement
 *
 * @param {Object} elem any JS Object
 */
const isHTMLElem = elem => elem instanceof HTMLElement;

const ERROR_MSG = {
    INTERFACE_IMPL: 'Method not implemented'
};

/**
 * Merges the sink object in the source by recursively iterating through the object properties
 * @param {Object} source Source Object
 * @param {Object} sink Sink Object
 * @return {Object} Merged object
 */
const mergeRecursive = (source, sink) => {
    for (const prop in sink) {
        if (isSimpleObject(source[prop]) &amp;&amp; isSimpleObject(sink[prop])) {
            mergeRecursive(source[prop], sink[prop]);
        } else if (sink[prop] instanceof Object &amp;&amp; sink[prop].constructor === Object) {
            source[prop] = {};
            mergeRecursive(source[prop], sink[prop]);
        } else {
            source[prop] = sink[prop];
        }
    }
    return source;
};

const interpolateArray = (data, fitCount) => {
    const linearInterpolate = function (before, after, atPoint) {
        return before + (after - before) * atPoint;
    };
    const newData = [];
    const springFactor = ((data.length - 1) / (fitCount - 1));
    newData[0] = data[0]; // for new allocation
    for (let i = 1; i &lt; fitCount - 1; i++) {
        const tmp = i * springFactor;
        const before = (Math.floor(tmp)).toFixed();
        const after = (Math.ceil(tmp)).toFixed();
        const atPoint = tmp - before;
        newData[i] = linearInterpolate(data[before], data[after], atPoint);
    }
    newData[fitCount - 1] = data[data.length - 1]; // for new allocation
    return newData;
};

/**
 *
 *
 * @param {*} fn
 */
const nextFrame = (fn) => {
    setTimeout(() => {
        fn();
    }, 0);
};

/**
 *
 *
 * @param {*} angle
 */
const angleToRadian = angle => angle * Math.PI / 180;

/**
 *
 *
 * @param {*} newName
 * @param {*} oldName
 */
const replaceCSSPrefix = () => {
    // @todo
};

/**
 * Gets the  interpolator function from d3 color
 *
 */
const interpolator = () => interpolate;

/**
 * Gets the number interpolator from d3 color
 *
 */
const numberInterpolator = () => interpolateNumber;

/**
 * Gets the rgb interpolator from d3 color
 *
 */
const colorInterpolator = () => interpolateRgb;

/**
 * Gets the hsl interpolator from d3 color
 *
 */
const hslInterpolator = () => interpolateHslLong;

const transformColors = () => ({
    color,
    rgb,
    hsl
});

/**
 * Gets the piecewise interpolator from d3 color
 *
 */
const piecewiseInterpolator = () => piecewise;

function hue2rgb (p, q, t) {
    if (t &lt; 0) t += 1;
    if (t > 1) t -= 1;
    if (t &lt; 1 / 6) return p + (q - p) * 6 * t;
    if (t &lt; 1 / 2) return q;
    if (t &lt; 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
}

  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h, s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * @param   Number  h       The hue
   * @param   Number  s       The saturation
   * @param   Number  l       The lightness
   * @return  Array           The RGB representation
   */
const hslToRgb = (h, s, l, a = 1) => {
    let r;
    let g;
    let b;

    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;

        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r * 255, g * 255, b * 255, a];
};

  /**
   * Converts an RGB color value to HSV. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h, s, and v in the set [0, 1].
   *
   * @param   Number  r       The red color value
   * @param   Number  g       The green color value
   * @param   Number  b       The blue color value
   * @return  Array           The HSV representation
   */
const rgbToHsv = (r, g, b, a = 1) => {
    r = +r; g = +g; b = +b; a = +a;
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h;
    let s;
    const l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // achromatic
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
        case r: h = (g - b) / d + (g &lt; b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
        default: break;
        }
        h /= 6;
    }
    return [h, s, l, a];
};

  /**
   * Converts an HSV color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
   * Assumes h, s, and v are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * @param   Number  h       The hue
   * @param   Number  s       The saturation
   * @param   Number  v       The value
   * @return  Array           The RGB representation
   */
const hsvToRgb = (h, s, v, a = 1) => {
    let r;
    let g;
    let b;

    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);

    switch (i % 6) {
    case 0: r = v; g = t; b = p; break;
    case 1: r = q; g = v; b = p; break;
    case 2: r = p; g = v; b = t; break;
    case 3: r = p; g = q; b = v; break;
    case 4: r = t; g = p; b = v; break;
    case 5: r = v; g = p; b = q; break;
    default: break;
    }

    return [r * 255, g * 255, b * 255, a];
};

const hexToHsv = (hex) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

    const r = parseInt(result[1], 16);
    const g = parseInt(result[2], 16);
    const b = parseInt(result[3], 16);
    const a = result[4] ? parseInt(result[4], 16) : 1;
    return rgbToHsv(r, g, b, a);
};

const detectColor = (col) => {
    const matchRgb = /rgb\((\d{1,3}), (\d{1,3}), (\d{1,3})\)/;
    const matchHsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g;

    // Source :  https://gist.github.com/sethlopezme/d072b945969a3cc2cc11
     // eslint-disable-next-line
    const matchRgba = /rgba?\(((25[0-5]|2[0-4]\d|1\d{1,2}|\d\d?)\s*,\s*?){2}(25[0-5]|2[0-4]\d|1\d{1,2}|\d\d?)\s*,?\s*([01]\.?\d*?)?\)/;
     // eslint-disable-next-line
    const matchHsla = /^hsla\((0|360|35\d|3[0-4]\d|[12]\d\d|0?\d?\d),(0|100|\d{1,2})%,(0|100|\d{1,2})%,(0?\.\d|1(\.0)?)\)$/;
    const matchHex = /^#([0-9a-f]{3}){1,2}$/i;

    if (matchRgb.test(col) || matchRgba.test(col)) {
        return 'rgb';
    } else if (matchHsl.test(col) || matchHsla.test(col)) {
        return 'hsl';
    } else if (matchHex.test(col)) {
        return 'hex';
    } return col;
};

/**
 *
 *
 * @param {*} model
 * @param {*} propModel
 *
 */
const filterPropagationModel = (model, propModel, measures) => {
    const { data, schema } = propModel.getData();
    let filteredModel;
    if (schema.length) {
        const fieldMap = model.getFieldsConfig();
        filteredModel = model.select((fields) => {
            const include = data.some(row => schema.every((propField, idx) => {
                if (!measures &amp;&amp; (!(propField.name in fieldMap) ||
                        fieldMap[propField.name].def.type === FieldType.MEASURE)) {
                    return true;
                }
                return row[idx] === fields[propField.name].valueOf();
            }));
            return include;
        }, {
            saveChild: false
        });
    } else {
        filteredModel = propModel;
    }

    return filteredModel;
};

const assembleModelFromIdentifiers = (model, identifiers) => {
    let schema = [];
    let data;
    const fieldMap = model.getFieldsConfig();
    if (identifiers.length) {
        const fields = identifiers[0];
        const len = fields.length;
        for (let i = 0; i &lt; len; i++) {
            const field = fields[i];
            const fieldObj = fieldMap[field] &amp;&amp; Object.assign({}, fieldMap[field].def);
            if (fieldObj) {
                schema.push(Object.assign(fieldObj));
            }
        }

        data = [];
        const header = identifiers[0];
        for (let i = 1; i &lt; identifiers.length; i += 1) {
            const vals = identifiers[i];
            const temp = {};
            vals.forEach((fieldVal, cIdx) => {
                temp[header[cIdx]] = fieldVal;
            });
            data.push(temp);
        }
    } else {
        data = [];
        schema = [];
    }

    return new model.constructor(data, schema);
};

/**
 *
 *
 * @param {*} dataModel
 * @param {*} criteria
 *
 */
const getDataModelFromRange = (dataModel, criteria, mode) => {
    if (criteria === null) {
        return null;
    }
    const selFields = Object.keys(criteria);
    const selFn = fields => selFields.every((field) => {
        const val = fields[field].value;
        const range = criteria[field][0] instanceof Array ? criteria[field][0] : criteria[field];
        if (typeof range[0] === 'string') {
            return range.find(d => d === val) !== undefined;
        }
        return range ? val >= range[0] &amp;&amp; val &lt;= range[1] : true;
    });

    return dataModel.select(selFn, {
        saveChild: false,
        mode
    });
};

/**
 *
 *
 * @param {*} dataModel
 * @param {*} identifiers
 *
 */
const getDataModelFromIdentifiers = (dataModel, identifiers, mode) => {
    let filteredDataModel;
    if (identifiers instanceof Array) {
        const fieldsConfig = dataModel.getFieldsConfig();

        const dataArr = identifiers.slice(1, identifiers.length);
        if (identifiers instanceof Function) {
            filteredDataModel = identifiers(dataModel, {}, false);
        } else if (identifiers instanceof Array &amp;&amp; identifiers[0].length) {
            const filteredSchema = identifiers[0].filter(d => d in fieldsConfig);
            filteredDataModel = dataModel.select((fields) => {
                let include = true;
                filteredSchema.forEach((propField, idx) => {
                    const value = fields[propField].valueOf();
                    const index = dataArr.findIndex(d => d[idx] === value);
                    include = include &amp;&amp; index !== -1;
                });
                return include;
            }, {
                saveChild: false,
                mode
            });
        }
    } else {
        filteredDataModel = getDataModelFromRange(dataModel, identifiers, mode);
    }
    return filteredDataModel;
};

/**
 *
 *
 * @param {*} context
 * @param {*} listenerMap
 */
const registerListeners = (context, listenerMap) => {
    const propListenerMap = listenerMap(context);
    for (const key in propListenerMap) {
        if ({}.hasOwnProperty.call(propListenerMap, key)) {
            const mapObj = propListenerMap[key];
            const propType = mapObj.type;
            const props = mapObj.props;
            const listenerFn = mapObj.listener;
            context.store()[propType](props, listenerFn);
        }
    }
};

const isValidValue = value => !isNaN(value) &amp;&amp; value !== -Infinity &amp;&amp; value !== Infinity;
/**
 *
 *
 * @param {*} obj
 * @param {*} fields
 *
 */
const getObjProp = (obj, ...fields) => {
    if (obj === undefined || obj === null) {
        return obj;
    }
    let retObj = obj;
    for (let i = 0, len = fields.length; i &lt; len; i++) {
        retObj = retObj[fields[i]];
        if (retObj === undefined || retObj === null) {
            break;
        }
    }
    return retObj;
};

/**
 *
 *
 * @param {*} str
 *
 */
const escapeHTML = (str) => {
    const htmlEscapes = {
        '&amp;': '&amp;amp;',
        '&lt;': '&amp;lt;',
        '>': '&amp;gt;',
        '"': '&amp;quot;',
        "'": '&amp;#x27;',
        '/': '&amp;#x2F;'
    };
    const htmlEscaper = /[&amp;&lt;>"'/]/g;
    return (`${str}`).replace(htmlEscaper, match => htmlEscapes[match]);
};

/**
 *
 *
 * @param {*} arr
 */
const transposeArray = arr => arr[0].map((col, i) => arr.map(row => row[i]));
const toArray = arr => (arr instanceof Array ? arr : [arr]);
const extendsClass = (cls, extendsFrom, found) => {
    if (!cls) {
        return false;
    }
    const prototype = cls.prototype;
    if (prototype instanceof extendsFrom) {
        found = true;
    } else {
        found = extendsClass(prototype, extendsFrom, found);
    }
    return found;
};

/**
 *
 * @param {*} dm1
 * @param {*} dm2
 */
const concatModels = (dm1, dm2) => {
    const dataObj1 = dm1.getData();
    const dataObj2 = dm2.getData();
    const data1 = dataObj1.data;
    const data2 = dataObj2.data;
    const schema1 = dataObj1.schema;
    const schema2 = dataObj2.schema;
    const tuples1 = {};
    const tuples2 = {};
    const commonTuples = {};
    for (let i = 0; i &lt; data1.length; i++) {
        for (let ii = 0; ii &lt; data2.length; ii++) {
            const row1 = data1[i];
            const row2 = data2[ii];
            const dim1Values = row1.filter((d, idx) => schema1[idx].type === FieldType.DIMENSION);
            const dim2Values = row2.filter((d, idx) => schema2[idx].type === FieldType.DIMENSION);
            const allDimSame = dim1Values.every(value => dim2Values.indexOf(value) !== -1);
            if (allDimSame) {
                const key = dim1Values.join();
                !commonTuples[key] &amp;&amp; (commonTuples[key] = {});
                row1.forEach((value, idx) => {
                    commonTuples[key][schema1[idx].name] = value;
                });
                row2.forEach((value, idx) => {
                    commonTuples[key][schema2[idx].name] = value;
                });
            } else {
                const dm1Key = dim1Values.join();
                const dm2Key = dim2Values.join();
                if (!commonTuples[dm1Key] &amp;&amp; !commonTuples[dm2Key]) {
                    !tuples1[dm1Key] &amp;&amp; (tuples1[dm1Key] = {});
                    !tuples2[dm2Key] &amp;&amp; (tuples2[dm2Key] = {});
                    row1.forEach((value, idx) => {
                        tuples1[dm1Key][schema1[idx].name] = value;
                    });
                    row2.forEach((value, idx) => {
                        tuples2[dm2Key][schema2[idx].name] = value;
                    });
                }
            }
        }
    }

    const commonSchema = [...schema1, ...schema2.filter(s2 => schema1.findIndex(s1 => s1.name === s2.name) === -1)];
    const data = [...Object.values(tuples1), ...Object.values(tuples2), ...Object.values(commonTuples)];
    return [data, commonSchema];
};

const getSymbol = type => symbol().type(symbolFns[type]);

const stackOrders = {
    [STACK_CONFIG.ORDER_NONE]: stackOrderNone,
    [STACK_CONFIG.ORDER_ASCENDING]: stackOrderAscending,
    [STACK_CONFIG.ORDER_DESCENDING]: stackOrderDescending
};
const stackOffsets = {
    [STACK_CONFIG.OFFSET_DIVERGING]: stackOffsetDiverging,
    [STACK_CONFIG.OFFSET_NONE]: stackOffsetNone,
    [STACK_CONFIG.OFFSET_EXPAND]: stackOffsetExpand,
    [STACK_CONFIG.OFFSET_WIGGLE]: stackOffsetWiggle
};

// eslint-disable-next-line require-jsdoc
const stack = params => d3Stack().keys(params.keys).offset(stackOffsets[params.offset])
                .order(stackOrders[params.order])(params.data);

/**
 * Groups the data into a hierarchical tree structure based on one or more fields.
 * @param { Object } params Configuration properties for nesting data
 * @param { Array.&lt;Array> } params.data Data which needs to be grouped
 * @param { Array.&lt;number> } params.keys Field indices by which the data will be grouped
 * @return { Array.&lt;Object> } Grouped data array
 */
const nestCollection = (params) => {
    const nestFn = nest();
    params.keys.forEach(key => nestFn.key(d => d[key]));
    return nestFn.entries(params.data);
};

const pathInterpolators = {
    curveLinear,
    curveStepAfter,
    curveStepBefore,
    curveStep,
    curveCatmullRom,
    stepAfter: curveStepAfter,
    catmullRom: curveCatmullRom,
    step: curveStep,
    stepBefore: curveStepBefore,
    linear: curveLinear
};

const Symbols = {
    axisLeft,
    axisRight,
    axisTop,
    axisBottom,
    line,
    area,
    pie,
    arc,
    nest
};

const Scales = {
    band: scaleBand
};

const getSmallestDiff = (points) => {
    points = points.sort((a, b) => a - b);
    let minDiff = points[1] - points[0];
    for (let i = 2; i &lt; points.length; i++) {
        minDiff = Math.min(minDiff, points[i] - points[i - 1]);
    }

    return minDiff;
};

const require = (lookupWhat, lookupDetails) => ({
    resolvable: (store) => {
        const lookupTarget = store[lookupWhat];
        const depArr = lookupDetails.slice(0, lookupDetails.length - 1);
        const fn = lookupDetails[lookupDetails.length - 1]; // fn

        const deps = depArr.map(str => lookupTarget[str]);
        return {
            fn: fn(...deps),
            depArr
        };
    }
});

const nextAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
    function (callback) {
        setTimeout(callback, 16);
    };

export {
    require,
    Scales,
    Symbols,
    pathInterpolators,
    stack,
    nestCollection,
    getSymbol,
    transformColors,
    detectColor,
    hexToHsv,
    hslToRgb,
    rgbToHsv,
    hsvToRgb,
    concatModels,
    toArray,
    angleToRadian,
    escapeHTML,
    generateGetterSetters,
    getArraySum,
    interpolator,
    piecewiseInterpolator,
    getDataModelFromIdentifiers,
    getDataModelFromRange,
    colorInterpolator,
    numberInterpolator,
    ERROR_MSG,
    reqAnimFrame,
    nextAnimFrame,
    filterPropagationModel,
    transposeArray,
    cancelAnimFrame,
    getMax,
    getMin,
    getDomainFromData,
    getUniqueId,
    mergeRecursive,
    unionDomain,
    symbolFns,
    easeFns,
    clone,
    isEqual,
    interpolateArray,
    getMinPoint,
    defaultValue,
    getMaxPoint,
    getClosestIndexOf,
    Voronoi,
    checkExistence,
    sanitizeIP,
    getMinDiff,
    capitalizeFirst,
    getWindow,
    getQualifiedClassName,
    Store,
    getDependencyOrder,
    objectIterator,
    intSanitizer,
    transactor,
    enableChainedTransaction,
    isHTMLElem,
    isSimpleObject,
    nextFrame,
    registerListeners,
    replaceCSSPrefix,
    getObjProp,
    extendsClass,
    assembleModelFromIdentifiers,
    isValidValue,
    hslInterpolator,
    getSmallestDiff
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="Axis%252525250AThis%2525252520file%2525252520declares%2525252520a%2525252520class%2525252520that%2525252520is%2525252520used%2525252520to%2525252520render%2525252520an%2525252520axis%2525252520to%2525252520add%2525252520%2525252520meaning%2525252520to%252525250Aplots.module_.html">Axis
This file declares a class that is used to render an axis to add  meaning to
plots.</a></li><li><a href="Axis%250AThis%2520file%2520exports%2520all%2520the%2520public%2520methods%2520and%2520classes%2520in%2520the%2520axis%2520module.module_.html">Axis
This file exports all the public methods and classes in the axis module.</a></li><li><a href="Axis%250AThis%2520file%2520exports%2520constants%2520that%2520are%2520used%2520to%2520reference%2520axis%2520orientations%250Ain%2520a%2520consistent%2520manner.module_.html">Axis
This file exports constants that are used to reference axis orientations
in a consistent manner.</a></li><li><a href="axis%250AThis%2520file%2520exports%2520constants%2520used%2520to%2520reference%2520scale%2520type%250Aconsistently%2520throughout%2520the%2520project.module_.html">axis
This file exports constants used to reference scale type
consistently throughout the project.</a></li><li><a href="module-ActionModel.html">ActionModel</a></li><li><a href="module-ArcLayer.html">ArcLayer</a></li><li><a href="module-AreaLayer.html">AreaLayer</a></li><li><a href="module-AxisConfig.html">AxisConfig</a></li><li><a href="module-BarLayer.html">BarLayer</a></li><li><a href="module-BaseLayer.html">BaseLayer</a></li><li><a href="module-Canvas.html">Canvas</a></li><li><a href="module-CanvasConfig.html">CanvasConfig</a></li><li><a href="module-Firebolt.html">Firebolt</a></li><li><a href="module-GenericBehaviour.html">GenericBehaviour</a></li><li><a href="module-GenericSideEffect.html">GenericSideEffect</a></li><li><a href="module-GlobalLegendConfig.html">GlobalLegendConfig</a></li><li><a href="module-GlobalOptions.html">GlobalOptions</a></li><li><a href="module-GridBandConfig.html">GridBandConfig</a></li><li><a href="module-GridLineConfig.html">GridLineConfig</a></li><li><a href="module-InteractionConfig.html">InteractionConfig</a></li><li><a href="module-LayerFactory.html">LayerFactory</a></li><li><a href="module-Layout.html">Layout</a></li><li><a href="module-LegendConfig.html">LegendConfig</a></li><li><a href="module-LifecycleEvents.html">LifecycleEvents</a></li><li><a href="module-LineLayer.html">LineLayer</a></li><li><a href="module-LocalOptions.html">LocalOptions</a></li><li><a href="module-PhysicalAction.html">PhysicalAction</a></li><li><a href="module-PointLayer.html">PointLayer</a></li><li><a href="module-SimpleCell.html">SimpleCell</a></li><li><a href="module-SpawnableSideEffect.html">SpawnableSideEffect</a></li><li><a href="module-TextLayer.html">TextLayer</a></li><li><a href="module-tickFormat.html">tickFormat</a></li><li><a href="module-TickLayer.html">TickLayer</a></li><li><a href="module-TooltipFormatter.html">TooltipFormatter</a></li><li><a href="module-visual-group_src_visual-group_local-options.html">visual-group/src/visual-group/local-options</a></li><li><a href="module-VisualCell.html">VisualCell</a></li><li><a href="Transform%250AThis%2520file%2520exports%2520a%2520function%2520that%2520is%2520used%2520to%2520implement%250Athe%2520identity%2520transformmodule_.html">Transform
This file exports a function that is used to implement
the identity transform</a></li><li><a href="Transform%250AThis%2520file%2520exports%2520the%2520transform%2520factory.module_.html">Transform
This file exports the transform factory.</a></li><li><a href="Transform%250AThis%2520module%2520exports%2520constants%2520that%2520are%2520used%2520to%2520reference%2520transforms%2520in%250Aa%2520consistent%2520manner%2520throughout%2520the%2520project.module_.html">Transform
This module exports constants that are used to reference transforms in
a consistent manner throughout the project.</a></li></ul><h3>Classes</h3><ul><li><a href="Axis%2525250AThis%25252520file%25252520declares%25252520a%25252520class%25252520that%25252520is%25252520used%25252520to%25252520render%25252520an%25252520axis%25252520to%25252520add%25252520%25252520meaning%25252520to%2525250Aplots.module_-SimpleAxis.html">SimpleAxis</a></li><li><a href="AxisCell.AxisCell.html">AxisCell</a></li><li><a href="BLANK.BlankCell.html">BlankCell</a></li><li><a href="CartesianEncoder.html">CartesianEncoder</a></li><li><a href="ColorAxis.module.exports.html">module.exports</a></li><li><a href="ComposedVars.html">ComposedVars</a></li><li><a href="ComposeVars.html">ComposeVars</a></li><li><a href="DataObject.html">DataObject</a></li><li><a href="DataObject.DataObject.html">DataObject</a></li><li><a href="EnterSelection.html">EnterSelection</a></li><li><a href="EnterSelection.EnterSelection.html">EnterSelection</a></li><li><a href="GenericLayout.html">GenericLayout</a></li><li><a href="GenericLayout.module.exports.html">module.exports</a></li><li><a href="GeomCell.GeomCell.html">GeomCell</a></li><li><a href="GridLayout.html">GridLayout</a></li><li><a href="GroupFireBolt.html">GroupFireBolt</a></li><li><a href="Legend.html">Legend</a></li><li><a href="Legend.module.exports.html">module.exports</a></li><li><a href="LegendFireBolt.html">LegendFireBolt</a></li><li><a href="LifeCycleManager.html">LifeCycleManager</a></li><li><a href="LifeCycleManager.module.exports.html">module.exports</a></li><li><a href="LineLayer.module.exports.html">module.exports</a></li><li><a href="MatrixResolver.html">MatrixResolver</a></li><li><a href="MatrixResolver.module.exports.html">module.exports</a></li><li><a href="module.html#.exports">exports</a></li><li><a href="module.exports_module.exports.html">exports</a></li><li><a href="module-BarLayer.html">BarLayer</a></li><li><a href="module-BaseLayer.html">BaseLayer</a></li><li><a href="module-Canvas.html">Canvas</a></li><li><a href="module-SimpleCell-SimpleCell.html">SimpleCell</a></li><li><a href="module-VisualCell-Axis.html">Axis</a></li><li><a href="module-VisualCell-BLANK.html">BLANK</a></li><li><a href="module-VisualCell-GeomCell.html">GeomCell</a></li><li><a href="module-VisualCell-Text.html">Text</a></li><li><a href="PointLayer.module.exports.html">module.exports</a></li><li><a href="PolarEncoder.html">PolarEncoder</a></li><li><a href="RetinalEncoder.html">RetinalEncoder</a></li><li><a href="Selection.html">Selection</a></li><li><a href="Selection.Selection.html">Selection</a></li><li><a href="SelectionBox.html">SelectionBox</a></li><li><a href="SelectionSet.html">SelectionSet</a></li><li><a href="ShapeAxis.module.exports.html">module.exports</a></li><li><a href="SimpleAxis.module.exports.html">module.exports</a></li><li><a href="SimpleCell.SimpleCell.html">SimpleCell</a></li><li><a href="SimpleGroup.html">SimpleGroup</a></li><li><a href="SimpleLegend.html">SimpleLegend</a></li><li><a href="SimpleVariable.html">SimpleVariable</a></li><li><a href="SizeAxis.module.exports.html">module.exports</a></li><li><a href="Store.html">Store</a></li><li><a href="Store.Store.html">Store</a></li><li><a href="SurrogateSideEffect.html">SurrogateSideEffect</a></li><li><a href="Text.TextCell.html">TextCell</a></li><li><a href="TimeAxis.html">TimeAxis</a></li><li><a href="Tooltip.html">Tooltip</a></li><li><a href="ValueMatrix.html">ValueMatrix</a></li><li><a href="Variable.html">Variable</a></li><li><a href="VisualEncoder.html">VisualEncoder</a></li><li><a href="VisualGroup.html">VisualGroup</a></li><li><a href="VisualGroup.VisualGroup.html">VisualGroup</a></li><li><a href="VisualMatrix.html">VisualMatrix</a></li><li><a href="VisualMatrix.module.exports.html">module.exports</a></li><li><a href="VisualUnit.html">VisualUnit</a></li><li><a href="Voronoi.html">Voronoi</a></li></ul><h3>Namespaces</h3><ul><li><a href="Muze.html">Muze</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_calculateDomainFromData">_calculateDomainFromData</a></li><li><a href="global.html#addClass">addClass</a></li><li><a href="global.html#addLayer">addLayer</a></li><li><a href="global.html#ANGLE">ANGLE</a></li><li><a href="global.html#angleToRadian">angleToRadian</a></li><li><a href="global.html#animateGroup">animateGroup</a></li><li><a href="global.html#appendElement">appendElement</a></li><li><a href="global.html#applyBorders">applyBorders</a></li><li><a href="global.html#applyInteractionStyle">applyInteractionStyle</a></li><li><a href="global.html#applyItemStyle">applyItemStyle</a></li><li><a href="global.html#applyStyle">applyStyle</a></li><li><a href="global.html#ARC">ARC</a></li><li><a href="global.html#arrangeComponents">arrangeComponents</a></li><li><a href="global.html#arraysEqual">arraysEqual</a></li><li><a href="global.html#attachDragEvent">attachDragEvent</a></li><li><a href="global.html#axes">axes</a></li><li><a href="global.html#AXIS">AXIS</a></li><li><a href="global.html#axisPlaceholderGn">axisPlaceholderGn</a></li><li><a href="global.html#BAR">BAR</a></li><li><a href="global.html#barEnterFn">barEnterFn</a></li><li><a href="global.html#BEFORE_UPDATE">BEFORE_UPDATE</a></li><li><a href="global.html#BORDER">BORDER</a></li><li><a href="global.html#BOTH">BOTH</a></li><li><a href="global.html#BOTTOM">BOTTOM</a></li><li><a href="global.html#BOTTOM_DIV_ID">BOTTOM_DIV_ID</a></li><li><a href="global.html#BOTTOM_MATRIX_HEIGHT">BOTTOM_MATRIX_HEIGHT</a></li><li><a href="global.html#BOTTOM_TABLE_ID">BOTTOM_TABLE_ID</a></li><li><a href="global.html#BREAK_PAGE">BREAK_PAGE</a></li><li><a href="global.html#breakMatrix">breakMatrix</a></li><li><a href="global.html#calcColSpan">calcColSpan</a></li><li><a href="global.html#calcRowSpan">calcRowSpan</a></li><li><a href="global.html#calculateBandSpace">calculateBandSpace</a></li><li><a href="global.html#calculateContinousSpace">calculateContinousSpace</a></li><li><a href="global.html#canvas">canvas</a></li><li><a href="global.html#capitalizeFirst">capitalizeFirst</a></li><li><a href="global.html#CARTESIAN">CARTESIAN</a></li><li><a href="global.html#CATEGORICAL">CATEGORICAL</a></li><li><a href="global.html#CELL">CELL</a></li><li><a href="global.html#cellRegistry">cellRegistry</a></li><li><a href="global.html#cellSpanMaker">cellSpanMaker</a></li><li><a href="global.html#CENTER_DIV_ID">CENTER_DIV_ID</a></li><li><a href="global.html#CENTER_TABLE_ID">CENTER_TABLE_ID</a></li><li><a href="global.html#centerMatrix">centerMatrix</a></li><li><a href="global.html#changeTickOrientation">changeTickOrientation</a></li><li><a href="global.html#checkExistence">checkExistence</a></li><li><a href="global.html#checkPath">checkPath</a></li><li><a href="global.html#clearCaching">clearCaching</a></li><li><a href="global.html#click">click</a></li><li><a href="global.html#clipElement">clipElement</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#COL">COL</a></li><li><a href="global.html#COLLAPSE">COLLAPSE</a></li><li><a href="global.html#COLOR">COLOR</a></li><li><a href="global.html#color">color</a></li><li><a href="global.html#colorInterpolator">colorInterpolator</a></li><li><a href="global.html#COLUMN">COLUMN</a></li><li><a href="global.html#COLUMN_MATRIX_HEIGHT">COLUMN_MATRIX_HEIGHT</a></li><li><a href="global.html#COLUMN_POINTER">COLUMN_POINTER</a></li><li><a href="global.html#COLUMN_SIZE_IS_EQUAL">COLUMN_SIZE_IS_EQUAL</a></li><li><a href="global.html#COLUMN_WIDTHS">COLUMN_WIDTHS</a></li><li><a href="global.html#columnFilter">columnFilter</a></li><li><a href="global.html#columnMatrix">columnMatrix</a></li><li><a href="global.html#COLUMNS">COLUMNS</a></li><li><a href="global.html#columns">columns</a></li><li><a href="global.html#computeLayoutMeasurements">computeLayoutMeasurements</a></li><li><a href="global.html#computeLogicalSpace">computeLogicalSpace</a></li><li><a href="global.html#concatModels">concatModels</a></li><li><a href="global.html#config">config</a></li><li><a href="global.html#CONFIG">CONFIG</a></li><li><a href="global.html#convertToVar">convertToVar</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createAxisCells">createAxisCells</a></li><li><a href="global.html#createElement">createElement</a></li><li><a href="global.html#createElements">createElements</a></li><li><a href="global.html#createHeaders">createHeaders</a></li><li><a href="global.html#createHeading">createHeading</a></li><li><a href="global.html#createLegend">createLegend</a></li><li><a href="global.html#createMatrixEachLevel">createMatrixEachLevel</a></li><li><a href="global.html#createMatrixInstances">createMatrixInstances</a></li><li><a href="global.html#createRetinalAxis">createRetinalAxis</a></li><li><a href="global.html#createScale">createScale</a></li><li><a href="global.html#createSelectedDataModel">createSelectedDataModel</a></li><li><a href="global.html#createSelection">createSelection</a></li><li><a href="global.html#createShape">createShape</a></li><li><a href="global.html#createSimpleAxis">createSimpleAxis</a></li><li><a href="global.html#createTextCells">createTextCells</a></li><li><a href="global.html#createTree">createTree</a></li><li><a href="global.html#createValueCells">createValueCells</a></li><li><a href="global.html#data">data</a></li><li><a href="global.html#DATA_UPDATE_COUNTER">DATA_UPDATE_COUNTER</a></li><li><a href="global.html#dataTypeScaleMap">dataTypeScaleMap</a></li><li><a href="global.html#DEFAULT_CONFIG">DEFAULT_CONFIG</a></li><li><a href="global.html#DEFAULT_CONFIGURATION">DEFAULT_CONFIGURATION</a></li><li><a href="global.html#DEFAULT_MEASUREMENTS">DEFAULT_MEASUREMENTS</a></li><li><a href="global.html#defaultConfig">defaultConfig</a></li><li><a href="global.html#defaultSizeValue">defaultSizeValue</a></li><li><a href="global.html#dehighlightPoint">dehighlightPoint</a></li><li><a href="global.html#dependencies">dependencies</a></li><li><a href="global.html#detail">detail</a></li><li><a href="global.html#DETAIL">DETAIL</a></li><li><a href="global.html#DIMENSION">DIMENSION</a></li><li><a href="global.html#DIMENSIONS">DIMENSIONS</a></li><li><a href="global.html#discreteRange">discreteRange</a></li><li><a href="global.html#dispatchBehaviour">dispatchBehaviour</a></li><li><a href="global.html#DISTRIBUTION">DISTRIBUTION</a></li><li><a href="global.html#drawArea">drawArea</a></li><li><a href="global.html#drawLine">drawLine</a></li><li><a href="global.html#drawText">drawText</a></li><li><a href="global.html#enableCaching">enableCaching</a></li><li><a href="global.html#enableChainedTransaction">enableChainedTransaction</a></li><li><a href="global.html#ENTRY_CELLS">ENTRY_CELLS</a></li><li><a href="global.html#equals">equals</a></li><li><a href="global.html#escapeHTML">escapeHTML</a></li><li><a href="global.html#EXIT_CELLS">EXIT_CELLS</a></li><li><a href="global.html#extraCellsRemover">extraCellsRemover</a></li><li><a href="global.html#extractUnitConfig">extractUnitConfig</a></li><li><a href="global.html#FACET">FACET</a></li><li><a href="global.html#FACET_HEADERS">FACET_HEADERS</a></li><li><a href="global.html#facetByFields">facetByFields</a></li><li><a href="global.html#fadeUnfadeSelection">fadeUnfadeSelection</a></li><li><a href="global.html#fields">fields</a></li><li><a href="global.html#filterPropagationModel">filterPropagationModel</a></li><li><a href="global.html#findInGroup">findInGroup</a></li><li><a href="global.html#findInPage">findInPage</a></li><li><a href="global.html#firebolt">firebolt</a></li><li><a href="global.html#focusUnfocusSelection">focusUnfocusSelection</a></li><li><a href="global.html#FORMAT">FORMAT</a></li><li><a href="global.html#generateAxisFromMap">generateAxisFromMap</a></li><li><a href="global.html#generateGetterSetters">generateGetterSetters</a></li><li><a href="global.html#generateMatrices">generateMatrices</a></li><li><a href="global.html#generatePlaceholders">generatePlaceholders</a></li><li><a href="global.html#getArraySum">getArraySum</a></li><li><a href="global.html#getAxesScales">getAxesScales</a></li><li><a href="global.html#getAxisConfig">getAxisConfig</a></li><li><a href="global.html#getAxisKey">getAxisKey</a></li><li><a href="global.html#getAxisOffset">getAxisOffset</a></li><li><a href="global.html#getAxisType">getAxisType</a></li><li><a href="global.html#getCellKey">getCellKey</a></li><li><a href="global.html#getD3Drag">getD3Drag</a></li><li><a href="global.html#getDataDomain">getDataDomain</a></li><li><a href="global.html#getDataModelFromIdentifiers">getDataModelFromIdentifiers</a></li><li><a href="global.html#getDataModelFromRange">getDataModelFromRange</a></li><li><a href="global.html#getDefaultMark">getDefaultMark</a></li><li><a href="global.html#getDependencyOrder">getDependencyOrder</a></li><li><a href="global.html#getDistributedHeight">getDistributedHeight</a></li><li><a href="global.html#getDistributedWidth">getDistributedWidth</a></li><li><a href="global.html#getDomain">getDomain</a></li><li><a href="global.html#getDomainBounds">getDomainBounds</a></li><li><a href="global.html#getDomainFromData">getDomainFromData</a></li><li><a href="global.html#getDrawingContext">getDrawingContext</a></li><li><a href="global.html#getElementsByClassName">getElementsByClassName</a></li><li><a href="global.html#getEncoder">getEncoder</a></li><li><a href="global.html#getEncodingFieldInf">getEncodingFieldInf</a></li><li><a href="global.html#getEvent">getEvent</a></li><li><a href="global.html#getExtremePoint">getExtremePoint</a></li><li><a href="global.html#getFieldNames">getFieldNames</a></li><li><a href="global.html#getGradientDomain">getGradientDomain</a></li><li><a href="global.html#getHeaderAxisFrom">getHeaderAxisFrom</a></li><li><a href="global.html#getHorizontalAxisSpace">getHorizontalAxisSpace</a></li><li><a href="global.html#getIndex">getIndex</a></li><li><a href="global.html#getInterpolatedData">getInterpolatedData</a></li><li><a href="global.html#getItemContainers">getItemContainers</a></li><li><a href="global.html#getItemMeasures">getItemMeasures</a></li><li><a href="global.html#getLayerByName">getLayerByName</a></li><li><a href="global.html#getLayersByType">getLayersByType</a></li><li><a href="global.html#getLegendSpace">getLegendSpace</a></li><li><a href="global.html#getLogicalSpace">getLogicalSpace</a></li><li><a href="global.html#getMatrixMeasurement">getMatrixMeasurement</a></li><li><a href="global.html#getMatrixModel">getMatrixModel</a></li><li><a href="global.html#getMax">getMax</a></li><li><a href="global.html#getMaxMeasures">getMaxMeasures</a></li><li><a href="global.html#getMaxPoint">getMaxPoint</a></li><li><a href="global.html#getMeasureInfo">getMeasureInfo</a></li><li><a href="global.html#getMembers">getMembers</a></li><li><a href="global.html#getMin">getMin</a></li><li><a href="global.html#getMinDiff">getMinDiff</a></li><li><a href="global.html#getMinMeasures">getMinMeasures</a></li><li><a href="global.html#getMinPoint">getMinPoint</a></li><li><a href="global.html#getMousePos">getMousePos</a></li><li><a href="global.html#getNearestPoint">getNearestPoint</a></li><li><a href="global.html#getNearestRange">getNearestRange</a></li><li><a href="global.html#getObjProp">getObjProp</a></li><li><a href="global.html#getPlotPointsFromIdentifiers">getPlotPointsFromIdentifiers</a></li><li><a href="global.html#getRenderDetails">getRenderDetails</a></li><li><a href="global.html#getScaleInfo">getScaleInfo</a></li><li><a href="global.html#getScaleType">getScaleType</a></li><li><a href="global.html#getScheme">getScheme</a></li><li><a href="global.html#getSchemeType">getSchemeType</a></li><li><a href="global.html#getSkeletons">getSkeletons</a></li><li><a href="global.html#getTranslatedPoints">getTranslatedPoints</a></li><li><a href="global.html#getUniqueId">getUniqueId</a></li><li><a href="global.html#getValidTransform">getValidTransform</a></li><li><a href="global.html#getVerticalAxisSpace">getVerticalAxisSpace</a></li><li><a href="global.html#getViewMatrices">getViewMatrices</a></li><li><a href="global.html#getViewMeasurements">getViewMeasurements</a></li><li><a href="global.html#getWindow">getWindow</a></li><li><a href="global.html#GRID_BANDS">GRID_BANDS</a></li><li><a href="global.html#GRID_HEIGHT">GRID_HEIGHT</a></li><li><a href="global.html#GRID_LINES">GRID_LINES</a></li><li><a href="global.html#GRID_WIDTH">GRID_WIDTH</a></li><li><a href="global.html#GUTTERSPACE">GUTTERSPACE</a></li><li><a href="global.html#HAS_DATA_UPDATED">HAS_DATA_UPDATED</a></li><li><a href="global.html#hasOwn">hasOwn</a></li><li><a href="global.html#HAVE_COLUMNS_CHANGED">HAVE_COLUMNS_CHANGED</a></li><li><a href="global.html#HAVE_ROWS_CHANGED">HAVE_ROWS_CHANGED</a></li><li><a href="global.html#HAVE_VALUES_CHANGED">HAVE_VALUES_CHANGED</a></li><li><a href="global.html#HEADER">HEADER</a></li><li><a href="global.html#headerCreator">headerCreator</a></li><li><a href="global.html#headerPlaceholderGn">headerPlaceholderGn</a></li><li><a href="global.html#height">height</a></li><li><a href="global.html#HEIGHT">HEIGHT</a></li><li><a href="global.html#hide">hide</a></li><li><a href="global.html#highlightPoint">highlightPoint</a></li><li><a href="global.html#hslInterpolator">hslInterpolator</a></li><li><a href="global.html#hslToRgb">hslToRgb</a></li><li><a href="global.html#hsvToRgb">hsvToRgb</a></li><li><a href="global.html#html">html</a></li><li><a href="global.html#ICON_MAP">ICON_MAP</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#indexedDomain">indexedDomain</a></li><li><a href="global.html#indexedDomainMeasure">indexedDomainMeasure</a></li><li><a href="global.html#indexedRange">indexedRange</a></li><li><a href="global.html#initCanvas">initCanvas</a></li><li><a href="global.html#initializeCacheMaps">initializeCacheMaps</a></li><li><a href="global.html#INITIALIZED">INITIALIZED</a></li><li><a href="global.html#INTERACTION">INTERACTION</a></li><li><a href="global.html#interpolator">interpolator</a></li><li><a href="global.html#intSanitizer">intSanitizer</a></li><li><a href="global.html#invert">invert</a></li><li><a href="global.html#isDistributionEqual">isDistributionEqual</a></li><li><a href="global.html#isEqual">isEqual</a></li><li><a href="global.html#isHTMLElem">isHTMLElem</a></li><li><a href="global.html#layerRegistry">layerRegistry</a></li><li><a href="global.html#layers">layers</a></li><li><a href="global.html#LAYERS">LAYERS</a></li><li><a href="global.html#LEFT">LEFT</a></li><li><a href="global.html#LEFT_MATRIX_WIDTH">LEFT_MATRIX_WIDTH</a></li><li><a href="global.html#LEFT_TABLE_ID">LEFT_TABLE_ID</a></li><li><a href="global.html#legendCreator">legendCreator</a></li><li><a href="global.html#legendInitializer">legendInitializer</a></li><li><a href="global.html#LINE">LINE</a></li><li><a href="global.html#LINEAR">LINEAR</a></li><li><a href="global.html#longtouch">longtouch</a></li><li><a href="global.html#makeElement">makeElement</a></li><li><a href="global.html#makeLinearGradient">makeLinearGradient</a></li><li><a href="global.html#MARGIN">MARGIN</a></li><li><a href="global.html#matrices">matrices</a></li><li><a href="global.html#MEASURE">MEASURE</a></li><li><a href="global.html#measurement">measurement</a></li><li><a href="global.html#MEASUREMENT">MEASUREMENT</a></li><li><a href="global.html#MEASURES">MEASURES</a></li><li><a href="global.html#mergeRecursive">mergeRecursive</a></li><li><a href="global.html#MIN_UNIT_HEIGHT">MIN_UNIT_HEIGHT</a></li><li><a href="global.html#MIN_UNIT_WIDTH">MIN_UNIT_WIDTH</a></li><li><a href="global.html#minUnitHeight">minUnitHeight</a></li><li><a href="global.html#minUnitWidth">minUnitWidth</a></li><li><a href="global.html#mount">mount</a></li><li><a href="global.html#MOUNT">MOUNT</a></li><li><a href="global.html#MOUNT_POINT">MOUNT_POINT</a></li><li><a href="global.html#mountPoint">mountPoint</a></li><li><a href="global.html#nestCollection">nestCollection</a></li><li><a href="global.html#nextFrame">nextFrame</a></li><li><a href="global.html#normalDomain">normalDomain</a></li><li><a href="global.html#normalizeFields">normalizeFields</a></li><li><a href="global.html#normalRange">normalRange</a></li><li><a href="global.html#numberFormat">numberFormat</a></li><li><a href="global.html#numberInterpolator">numberInterpolator</a></li><li><a href="global.html#objectIterator">objectIterator</a></li><li><a href="global.html#oneVar">oneVar</a></li><li><a href="global.html#orderFields">orderFields</a></li><li><a href="global.html#ORDINAL">ORDINAL</a></li><li><a href="global.html#palette">palette</a></li><li><a href="global.html#parentAlias">parentAlias</a></li><li><a href="global.html#piecewiseInterpolator">piecewiseInterpolator</a></li><li><a href="global.html#pieceWiseRange">pieceWiseRange</a></li><li><a href="global.html#PIVOT">PIVOT</a></li><li><a href="global.html#placeArrow">placeArrow</a></li><li><a href="global.html#POINT">POINT</a></li><li><a href="global.html#POLAR">POLAR</a></li><li><a href="global.html#position">position</a></li><li><a href="global.html#positionRelativeTo">positionRelativeTo</a></li><li><a href="global.html#prepareGridContainer">prepareGridContainer</a></li><li><a href="global.html#prepareLayout">prepareLayout</a></li><li><a href="global.html#PRIMARY">PRIMARY</a></li><li><a href="global.html#projectRows">projectRows</a></li><li><a href="global.html#pushToMatrix">pushToMatrix</a></li><li><a href="global.html#RADIUS">RADIUS</a></li><li><a href="global.html#registerListeners">registerListeners</a></li><li><a href="global.html#removeClass">removeClass</a></li><li><a href="global.html#removeLayerByName">removeLayerByName</a></li><li><a href="global.html#removeLayersByType">removeLayersByType</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#renderAxis">renderAxis</a></li><li><a href="global.html#renderComponents">renderComponents</a></li><li><a href="global.html#renderHeader">renderHeader</a></li><li><a href="global.html#renderIcon">renderIcon</a></li><li><a href="global.html#renderLegend">renderLegend</a></li><li><a href="global.html#renderMatrices">renderMatrices</a></li><li><a href="global.html#renderMatrix">renderMatrix</a></li><li><a href="global.html#renderTable">renderTable</a></li><li><a href="global.html#replaceCSSPrefix">replaceCSSPrefix</a></li><li><a href="global.html#reqAnimFrame">reqAnimFrame</a></li><li><a href="global.html#resetData">resetData</a></li><li><a href="global.html#resolveDimByField">resolveDimByField</a></li><li><a href="global.html#resolveDimensions">resolveDimensions</a></li><li><a href="global.html#resolver">resolver</a></li><li><a href="global.html#resolveTitleSubTitleContent">resolveTitleSubTitleContent</a></li><li><a href="global.html#RETINAL">RETINAL</a></li><li><a href="global.html#retinalFields">retinalFields</a></li><li><a href="global.html#retriveDomainFromData">retriveDomainFromData</a></li><li><a href="global.html#rgbToHsv">rgbToHsv</a></li><li><a href="global.html#RIGHT">RIGHT</a></li><li><a href="global.html#RIGHT_MATRIX_WIDTH">RIGHT_MATRIX_WIDTH</a></li><li><a href="global.html#RIGHT_TABLE_ID">RIGHT_TABLE_ID</a></li><li><a href="global.html#rotateAxis">rotateAxis</a></li><li><a href="global.html#ROW">ROW</a></li><li><a href="global.html#ROW_HEIGHTS">ROW_HEIGHTS</a></li><li><a href="global.html#ROW_MATRIX_WIDTH">ROW_MATRIX_WIDTH</a></li><li><a href="global.html#ROW_POINTER">ROW_POINTER</a></li><li><a href="global.html#ROW_SIZE_IS_EQUAL">ROW_SIZE_IS_EQUAL</a></li><li><a href="global.html#rowMatrix">rowMatrix</a></li><li><a href="global.html#ROWS">ROWS</a></li><li><a href="global.html#rows">rows</a></li><li><a href="global.html#SECONDARY">SECONDARY</a></li><li><a href="global.html#selectElement">selectElement</a></li><li><a href="global.html#serialize">serialize</a></li><li><a href="global.html#setAttrs">setAttrs</a></li><li><a href="global.html#setAxisNamePos">setAxisNamePos</a></li><li><a href="global.html#setElementAttrs">setElementAttrs</a></li><li><a href="global.html#setFixedBaseline">setFixedBaseline</a></li><li><a href="global.html#setLabelRotationForAxes">setLabelRotationForAxes</a></li><li><a href="global.html#setMatrixMeasurement">setMatrixMeasurement</a></li><li><a href="global.html#setStyles">setStyles</a></li><li><a href="global.html#setupChangeListener">setupChangeListener</a></li><li><a href="global.html#setupChangeListeners">setupChangeListeners</a></li><li><a href="global.html#SHAPE">SHAPE</a></li><li><a href="global.html#shape">shape</a></li><li><a href="global.html#shapeGenerator">shapeGenerator</a></li><li><a href="global.html#share">share</a></li><li><a href="global.html#shiftHeaders">shiftHeaders</a></li><li><a href="global.html#show">show</a></li><li><a href="global.html#SHOW_COL_BORDERS">SHOW_COL_BORDERS</a></li><li><a href="global.html#SHOW_ROW_BORDERS">SHOW_ROW_BORDERS</a></li><li><a href="global.html#SHOW_VALUE_BORDERS">SHOW_VALUE_BORDERS</a></li><li><a href="global.html#size">size</a></li><li><a href="global.html#SIZE">SIZE</a></li><li><a href="global.html#spaceTakenByColumn">spaceTakenByColumn</a></li><li><a href="global.html#spaceTakenByRow">spaceTakenByRow</a></li><li><a href="global.html#SPACING">SPACING</a></li><li><a href="global.html#steppedDomain">steppedDomain</a></li><li><a href="global.html#strategies">strategies</a></li><li><a href="global.html#strategy">strategy</a></li><li><a href="global.html#strategyGetter">strategyGetter</a></li><li><a href="global.html#STYLE">STYLE</a></li><li><a href="global.html#subtitle">subtitle</a></li><li><a href="global.html#subtype">subtype</a></li><li><a href="global.html#TEMPORAL">TEMPORAL</a></li><li><a href="global.html#title">title</a></li><li><a href="global.html#titleCreator">titleCreator</a></li><li><a href="global.html#TOP">TOP</a></li><li><a href="global.html#TOP_DIV_ID">TOP_DIV_ID</a></li><li><a href="global.html#TOP_MATRIX_HEIGHT">TOP_MATRIX_HEIGHT</a></li><li><a href="global.html#TOP_TABLE_ID">TOP_TABLE_ID</a></li><li><a href="global.html#touchdrag">touchdrag</a></li><li><a href="global.html#transactor">transactor</a></li><li><a href="global.html#transform">transform</a></li><li><a href="global.html#TRANSFORM">TRANSFORM</a></li><li><a href="global.html#transformData">transformData</a></li><li><a href="global.html#transformFields">transformFields</a></li><li><a href="global.html#transitionBars">transitionBars</a></li><li><a href="global.html#transposeArray">transposeArray</a></li><li><a href="global.html#treeShakeNode">treeShakeNode</a></li><li><a href="global.html#type">type</a></li><li><a href="global.html#unionDomain">unionDomain</a></li><li><a href="global.html#unique">unique</a></li><li><a href="global.html#uniqueKeyGenerator">uniqueKeyGenerator</a></li><li><a href="global.html#uniqueRange">uniqueRange</a></li><li><a href="global.html#UNIT">UNIT</a></li><li><a href="global.html#UNIT_HEIGHT">UNIT_HEIGHT</a></li><li><a href="global.html#UNIT_WIDTH">UNIT_WIDTH</a></li><li><a href="global.html#update">update</a></li><li><a href="global.html#updateCells">updateCells</a></li><li><a href="global.html#UPDATED">UPDATED</a></li><li><a href="global.html#updateScaleRange">updateScaleRange</a></li><li><a href="global.html#updateStyle">updateStyle</a></li><li><a href="global.html#VALUE_MATRIX">VALUE_MATRIX</a></li><li><a href="global.html#VIEW_INDEX">VIEW_INDEX</a></li><li><a href="global.html#width">width</a></li><li><a href="global.html#WIDTH">WIDTH</a></li><li><a href="global.html#X">X</a></li><li><a href="global.html#X_AXES">X_AXES</a></li><li><a href="global.html#Y">Y</a></li><li><a href="global.html#Y_AXES">Y_AXES</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Nov 01 2018 13:58:03 GMT+0530 (IST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
